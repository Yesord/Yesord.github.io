[{"id":"0efe1085ac0265965eb4a094f23bbe8f","title":"Keil编译常见Error及其解决方案","content":"Keil编译常见Error及其解决方案这里总结了本人使用Keil所遇到过的所有编译报错，并附上解决方案可供参考。\nError: L6218E: Undefined symbol __aeabi_assert (referred from xxx.o).原因：引用 #include &lt;assert.h&gt; 断言功能缺失方案一未定义的符号__aeabi_assert,原因是keil没有添加依赖项，请在 Manage Run-time Evironment 中添加即可。Compiler–&gt; I&#x2F;O –&gt; STDERR\n方案二bash\n__attribute__((weak,noreturn))\nvoid __aeabi_assert (const char *expr, const char *file, int line) &#123;\n  char str[12], *p;\n\n  fputs(&quot;*** assertion failed: &quot;, stderr);\n  fputs(expr, stderr);\n  fputs(&quot;, file &quot;, stderr);\n  fputs(file, stderr);\n  fputs(&quot;, line &quot;, stderr);\n\n  p = str + sizeof(str);\n  *--p = &#39;\\0&#39;;\n  *--p = &#39;\\n&#39;;\n  while (line &gt; 0) &#123;\n    *--p = &#39;0&#39; + (line % 10);\n    line /= 10;\n  &#125;\n  fputs(p, stderr);\n\n  abort();\n&#125;\n\n__attribute__((weak))\nvoid abort(void) &#123;\n  for (;;);\n&#125;\n在使用Arm MicroLIB C库时，实现一个自定义的__aeabi_assert()函数。使用上面的代码作为模板。\n禁用assert(): On Project -&gt; Options For Target -&gt; On C&#x2F; c++选项卡，用于定义类型“NDEBUG”。-这会导致对assert()函数的调用不起作用。\n禁用MicroLIB:在Target对话框右上方的Project -&gt; Options For Target -&gt;下，取消选中Use MicroLIB以禁用Arm MicroLIB C库。\n修改完成后，重新构建项目使其生效。————————————————可参考链接：https://blog.csdn.net/qq_29246181/article/details/128777718\nError: L6218E: Undefined symbol xxx (referred from xxx.o)原因：函数未定义解决方案：确定该函数的调用在什么地方出现问题1.检查头文件路径2.探查函数是否有定义 ctrl+F\n","slug":"Keil编译常见Error及其解决方案","date":"2023-10-20T14:28:16.000Z","categories_index":"Embedded","tags_index":"IDE","author_index":"PIKO"},{"id":"773c209899ecce00873dc4bef3ff4375","title":"STM32F103RCT6扩展板设计","content":"STM32F103RCT6扩展板电路设计这里主要提供设计思路，未包括STM32的供电电路、晶振时钟电路、复位电路(默认构成了最小系统)。\n","slug":"STM32F103RCT6扩展板设计","date":"2023-10-20T13:50:03.000Z","categories_index":"","tags_index":"STM32,Electronic","author_index":"PIKO"},{"id":"de085bbc27b1fb479554dba220957700","title":"关于学习模式的讨论","content":"今天与项目导师交流立项意见，受益良多。\nAI的崛起是必然的作为大二的鼠鼠很少还去关注研究生的专业，从导师处了解到本来应该只是计软院开的ai专业逐渐渗透到别的院里，不管是电信还是机电都开设了研究生ai相关专业。而ai在各个领域的表现是显而易见的。原先的理念逐渐被打破，以测试员为例：原先都是说老练的测试员更吃香，究其源是干过几个项目后手里都有一些项目数据和项目模板可供搭建，在之后的项目中可以沿用之前的项目而在此基础之上作修改以适配现有项目。再资深的测试员经过再多的项目积累手里也不可能会有几百份项目报告，而ai在深度学习之后能在几分钟内给出成百上千份项目报告。而在底层架构上，ai是完爆人类的，你不会指望着你一个才学了2、3年的C语言编写出来的程序架构能和ai写出来的掰手腕的。\nAI时代下的学习模式当下绝大部分课本的学习模式都是从最底层开始搭建，先教会如何搭砖头在学如何砌墙。模电从二极管开始学、数电以芯片为主导……这些都太细了。一本书要学一个学期的时间(当然有些是基础是必然要这么学的，凡事不能片面化~~)，而新时代的变革是飞快的，一本书学个一年半载的效率实在是太低了，你可能学完了，但是ai能比你实现的更好。现在需要的是快速学习的能力，需要的是从上而下的学习，先学会快速搭建，之后在慢慢搞懂底层逻辑。从理论开始一点一点的学不仅难而且实现功能的周期太长。导师提出在以后工作中应该也会遇到如此情况：老板今天看到一个好的实例，给你一点相关资料(甚至不给)，让你在一周之内搭建实现这个实例，你要在这一周之内搞懂其实现原理并复现出来把老板讲懂(有些情况下甚至不需要你搞懂，可能会有相关技术人员去实现)，你要给出方案，在这一周之内。。。快速学习的能力不言而喻了吧。\n具体实现我们可以这样认为，我们手里拿的书都是只有翻一页才会展示下一页的知识，下一个要用的知识永远是未知的，因而需要保持长久的好奇心与适应力去接受新事物。实际一点来说，我们拿到一本书首先是去翻看目录，花去一小段时间去建立整个知识体系，能快速检索到或实现想要达成的目标，回过头来在好好琢磨一些核心底层问题。总而言之，学习是永无止境的，重要是能弄明白你在学什么，别当无头苍蝇。\n","slug":"关于学习模式的讨论","date":"2023-10-19T11:52:41.000Z","categories_index":"tittle-tattle","tags_index":"undefined","author_index":"PIKO"},{"id":"507d422f151c505ace4132bc7d4f4fff","title":"LVGL的移植","content":"前言LVGL是一个免费好用的嵌入式GUI库，其控件扁平化，符合当今大众审美，主要应用在一些像智能手表之类的产品之上。前几天刚搞到一块STM32F103RCT6的最小系统板+ST7735S的TFT-LCD（可惜了不是触摸屏QAQ），今咱就来尝试移植一下LVGL到STM32上，整点炫的。\nLVGL的移植流程以STM32F103RCT6为例\nLVGL源码下载Github仓库地址 https://github.com/lvgl/lvgl\n准备工作准备LVGL源码修改lv_conf.h文件，修改条件编译\n删除不必要文件\n添加工程文件需要添加文件需要添加头文件路径特殊配置(可选)屏蔽warning\n修改工程文件(裸机开发)总体配置修改lv_conf.h\nbash\n/* clang-format off */\n#if 1 /*Set it to &quot;1&quot; to enable content*/\n// 原先这里是#if 0 需改成 #if 1\n添加output设备修改lv_port_disp_template.h为lv_port_disp.h对应的头文件名在对应c文件中也要更改\nbash\n/*Copy this file as &quot;lv_port_disp.h&quot; and set this value to &quot;1&quot; to enable content*/\n#if 1 //使能lv_port_disp.h\n\n修改lv_port_disp_template.c使用的buffer算法（三选一）有详细介绍，可以认为从上到下性能递增，占用内存也递增\nbash\n/* Example for 1) */\n    static lv_disp_draw_buf_t draw_buf_dsc_1;\n    static lv_color_t buf_1[MY_DISP_HOR_RES * 10];                          /*A buffer for 10 rows*/\n    lv_disp_draw_buf_init(&amp;draw_buf_dsc_1, buf_1, NULL, MY_DISP_HOR_RES * 10);   /*Initialize the display buffer*/\n\n//    /* Example for 2) */\n//    static lv_disp_draw_buf_t draw_buf_dsc_2;\n//    static lv_color_t buf_2_1[MY_DISP_HOR_RES * 10];                        /*A buffer for 10 rows*/\n//    static lv_color_t buf_2_2[MY_DISP_HOR_RES * 10];                        /*An other buffer for 10 rows*/\n//    lv_disp_draw_buf_init(&amp;draw_buf_dsc_2, buf_2_1, buf_2_2, MY_DISP_HOR_RES * 10);   /*Initialize the display buffer*/\n\n//    /* Example for 3) also set disp_drv.full_refresh = 1 below*/\n//    static lv_disp_draw_buf_t draw_buf_dsc_3;\n//    static lv_color_t buf_3_1[MY_DISP_HOR_RES * MY_DISP_VER_RES];            /*A screen sized buffer*/\n//    static lv_color_t buf_3_2[MY_DISP_HOR_RES * MY_DISP_VER_RES];            /*Another screen sized buffer*/\n//    lv_disp_draw_buf_init(&amp;draw_buf_dsc_3, buf_3_1, buf_3_2,\n//                          MY_DISP_VER_RES * LV_VER_RES_MAX);   /*Initialize the display buffer*/\n\n// 修改 disp_init 放入自己的屏幕驱动\n\n/*Initialize your display and the required peripherals.*/\nstatic void disp_init(void)\n&#123;\n    /*You code here*/\n  LCD_Init();\n  \n&#125;\n\n// 修改 disp_flush 放入自己屏幕的色块填充程序\n\n/*Flush the content of the internal buffer the specific area on the display\n *You can use DMA or any hardware acceleration to do this operation in the background but\n *&#39;lv_disp_flush_ready()&#39; has to be called when finished.*/\nstatic void disp_flush(lv_disp_drv_t * disp_drv, const lv_area_t * area, lv_color_t * color_p)\n&#123;\n//    if(disp_flush_enabled) &#123;\n//        /*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/\n\n//        int32_t x;\n//        int32_t y;\n//        for(y = area-&gt;y1; y &lt;= area-&gt;y2; y++) &#123;\n//            for(x = area-&gt;x1; x &lt;= area-&gt;x2; x++) &#123;\n//                /*Put a pixel to the display. For example:*/\n//                /*put_px(x, y, *color_p)*/\n//                color_p++;\n//            &#125;\n//        &#125;\n//    &#125;\n    LCD_Fill(area-&gt;x1,area-&gt;y1,area-&gt;x2,area-&gt;y2,(uint16_t)color_p);\n    /*IMPORTANT!!!\n     *Inform the graphics library that you are ready with the flushing*/\n    lv_disp_flush_ready(disp_drv);\n&#125;\n添加input设备bash\n\n\n添加lvgl时基定时器驱动文件加入 #include”lvgl.h”定时器中断设置1ms中断，放入lv_tick_inc\nbash\nvoid TIM3_Handler(void)&#123; //定时器配置1ms中断\n    lv_tick_inc(1);\n&#125;\n\n测试程序可能无法显示需要去改startup文件的堆栈大小 \nFreeRTOS下的移植基本同裸机的配置相差不大，也就需要改个时基，使用FreeRTOS的\n时基配置lv_conf.h中添加自定义时基\nbash\n/*Use a custom tick source that tells the elapsed time in milliseconds.\n *It removes the need to manually update the tick with `lv_tick_inc()`)*/\n#define LV_TICK_CUSTOM 1 //使能1，默认是0\n#if LV_TICK_CUSTOM\n    #define LV_TICK_CUSTOM_INCLUDE &quot;FreeRTOS.h&quot;         /*Header for the system time function*/\n    #define LV_TICK_CUSTOM_SYS_TIME_EXPR (xTaskGetTickCount())    /*Expression evaluating to current system time in ms*/\n注意该配置与裸机移植的配置不能兼容。\n后记刚学LVGL，移个植都费劲，库函数也还没理清，路漫漫其修远兮啊。。。\n","slug":"LVGL的移植","date":"2023-10-18T14:26:45.000Z","categories_index":"Embedded","tags_index":"TPSW","author_index":"PIKO"},{"id":"11caf7d9cf7a688f2728c9360ab7d311","title":"图片转链接--SM.MS图床","content":"SM.SM图床网站推荐引言平时大家编写.md文件时肯定有对图片有所苦恼。正常从本机引用的话，跨设备图片就会无法显示，如果调到github仓库里又会比较麻烦。\n大家肯定会想要一个方法既能解决跨设备图片显示，操作起来又没那么困难的方法。\n正文在这里给大家推荐一个网站 https://smms.app/\n其界面UI如下：\n可以支持五种链接格式\n结语阿巴阿巴阿巴阿巴阿巴\n","slug":"图片转链接-SM-MS图床","date":"2023-10-17T14:01:58.000Z","categories_index":"Internet","tags_index":"tool","author_index":"PIKO"},{"id":"7306721a27e9ec7e2372287f94d883c8","title":"Cmake基础语法","content":"Cmake基础语法bash# 设置cmake最低版本\ncmake_minimum_required(VERSION 3.2)\n\n# project命令用于指定cmake工程的名称，实际上，它还可以指定cmake工程的版本号（VERSION关键字）、简短的描述（DESCRIPTION关键字）、主页URL（HOMEPAGE_URL关键字）和编译工程使用的语言（LANGUAGES关键字）\n# project(&lt;PROJECT-NAME&gt; [&lt;language-name&gt;...])\n# project(&lt;PROJECT-NAME&gt; [VERSION &lt;major&gt;[.&lt;minor&gt;[.&lt;patch&gt;[.&lt;tweak&gt;]]]] [DESCRIPTION &lt;project-description-string&gt;][HOMEPAGE_URL &lt;url-string&gt;] [LANGUAGES &lt;language-name&gt;...])\n# $&#123;PROJECT_SOURCE_DIR&#125; 和 &lt;PROJECT-NAME&gt;_SOURCE_DIR：本CMakeLists.txt所在的文件夹路径\n# $&#123;PROJECT_NAME&#125;：本CMakeLists.txt的project名称\nproject(xxx)\nproject(mytest VERSION 1.2.3.4)\nproject (mytest HOMEPAGE_URL “https://www.XXX(示例).com”)\n\n# 获取路径下所有的.cpp/.c/.cc文件（不包括子目录），并赋值给变量中\naux_source_directory(路径 变量)\n\n# GLOB_RECURSE 获取目录下的所有cpp文件（不包括子目录），并赋值给SOURCES\nfile(\n        GLOB SOURCES\n        $&#123;PROJECT_SOURCE_DIR&#125;/*.c\n\n)\n# GLOB_RECURSE 获取目录下的所有cpp文件（包括子目录），并赋值给NATIVE_SRC\nfile(\n      GLOB_RECURSE NATIVE_SRC \n      $&#123;PROJECT_SOURCE_DIR&#125;/lib/*.cpp\n)\n\n# 给文件名/路径名或其他字符串起别名，用$&#123;变量&#125;获取变量内容\nset(变量 文件名/路径/...)\n\n# 添加编译选项FOO BAR\n# add_definitions定义宏，但是这种定义方式无法给宏具体值 等价C语言中的#define  MG_ENABLE_OPENSSL\nadd_definitions(-DFOO -DBAR ...)\n\n# add_compile_definitions定义宏，这种方式可以给宏具体值，但是这个指令只要高版本的cmake支持 等价C语言中 #define  MG_ENABLE_OPENSSL   1 \nadd_compile_definitions(MG_ENABLE_OPENSSL=1)\n\n# 打印消息\nmessage(消息)\n\n# 编译子文件夹的CMakeLists.txt\nadd_subdirectory(子文件夹名称)\n\n# 将.cpp/.c/.cc文件生成.a静态库\n# 注意，库文件名称通常为libxxx.so，在这里只要写xxx即可\nadd_library(库文件名称 STATIC 文件)\n\n# 将.cpp/.c/.cc文件生成可执行文件\nadd_executable(可执行文件名称 文件)\n\n# 规定.h头文件路径\ninclude_directories(路径)\n\n# 规定.so/.a库文件路径\nlink_directories(路径)\n\n# 设置编译选项及默认值\noption(TEST_DEBUG &quot;option for debug&quot; OFF)\n\n# 对add_library或add_executable生成的文件进行链接操作\n# 注意，库文件名称通常为libxxx.so，在这里只要写xxx即可\ntarget_link_libraries(库文件名称/可执行文件名称 链接的库文件名称)\n\n \n基础配置流程\nproject(xxx)                                          #必须\n\nadd_subdirectory(子文件夹名称)                         #父目录必须，子目录不必\n\nadd_library(库文件名称 STATIC 文件)                    #通常子目录(二选一)\nadd_executable(可执行文件名称 文件)                     #通常父目录(二选一)\n\ninclude_directories(路径)                              #必须\nlink_directories(路径)                                 #必须\n\ntarget_link_libraries(库文件名称/可执行文件名称 链接的库文件名称)       #必须\n     ","slug":"Cmake基础语法","date":"2023-10-17T11:57:43.000Z","categories_index":"Embedded","tags_index":"Linux,Cmake","author_index":"PIKO"},{"id":"92468dc8f04e07f9e105708cbbdde9c2","title":"FreeRTOS的移植","content":"FreeRTOS的移植介绍下FreeRTOS源码内容\n\n\n名称\n描述\n\n\n\nFreeRTOS\nFreeRTOS内核\n\n\nFreeRTOS-Plus\nFreeRTOS组件\n\n\ntools\n工具\n\n\nGitHub-FreeRTOS-Home\nFreeRTOS的GitHub仓库链接\n\n\nQuick_Start_Guide\n快速入门指南官方文档链接\n\n\nUpgrading-to-FreeRTOS-xxx\n升级到指定FreeRTOS版本官方文档链接\n\n\nHistory.txt\nFreeRTOS历史更新记录\n\n\n其他\n其他\n\n\nFreeRTOS内核\n\n\n名称\n描述\n\n\n\nDemo\nFreeRTOS演示例程\n\n\nLicense\nFreeRTOS相关许可\n\n\nSource\nFreeRTOS源码（主要拷贝）\n\n\nTest\n公用以及移植层测试代码\n\n\nSource文件夹freeRTOS源码\n\n\n\n名称\n描述\n\n\n\ninclude\n内包含了FreeRTOS的头文件\n\n\nportable\n内包含了FreeRTOS的移植文件\n\n\ncroutine.c\n协程相关文件\n\n\nevent_groups.c\n事件相关文件\n\n\nlist.c\n列表相关文件（状态相关，必要）\n\n\nqueue.c\n队列相关文件（状态相关，必要）\n\n\nstream_buffer.c\n流式缓冲区相关文件\n\n\ntasks.c\n任务相关文件（必要）\n\n\ntimers.c\n软件定时器相关文件\n\n\nportable文件夹freeRTOS与硬件交互的桥梁\n\n\n\n名称\n描述\n\n\n\nKeil\n指向RVDS文件夹\n\n\nRVDS\n不同内核芯片的移植文件\n\n\nMemMang\n内存管理文件（5种算法）\n\n\n其他的文件用不着可以删掉\nFreeRTOS移植步骤以STM32F103为例\n1．添加FreeRTOS源码添加入工程\nFreeRTOS源码导入工程\nportable里这些文件导入工程(其他的删掉!!)\n在Keil中建立如下组\n注意配置头文件地址\n2．添加FreeRTOSConfig.h作用：对FreeRTOS进行配置和裁剪，以及API函数的使能操作系统配置文件:获取途径\na.自己手写FreeRTOS官网有详细说明（https://www.freertos.org/a00110.html）\nb.Demo例程或许有官方支持（但也不全，还没很多的注释，建议还是自己写）\nDemo这个里的FreeRTOSConfig.h可使用\nc.参考我写哒\nbash\n#ifndef FREERTOS_CONFIG_H\n#define FREERTOS_CONFIG_H\n\n/*-----------------------------------------------------------\n * Application specific definitions.\n *\n * These definitions should be adjusted for your particular hardware and\n * application requirements.\n *\n * THESE PARAMETERS ARE DESCRIBED WITHIN THE &#39;CONFIGURATION&#39; SECTION OF THE\n * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE.\n *\n * See http://www.freertos.org/a00110.html\n *----------------------------------------------------------*/\n\n#define configUSE_PREEMPTION\t\t1   //使用抢占式内核\n//#define configUSE_TIME_SLICING  1   //使用时间片调度（默认是使能的）\n#define configUSE_IDLE_HOOK\t\t\t0   //使用模式的钩子函数\n#define configUSE_TICK_HOOK\t\t\t0   //使用TICK的钩子函数\n#define configUSS_PORT_OPTIMISED_SELECTION  1  //1使用硬件选择下一个执行任务 （需要架构拥有计算前导零[CLZ]的指令）\n#define configUSE_TICKLESS_IDLE 0   //1使用低功耗模式\n#define configUSE_QUEUE_SETS    1   //1使用队列集\n#define configCPU_CLOCK_HZ\t\t\t( ( unsigned long ) 72000000 )  //CPU主频\n//#define configSYSTICK_CLOCK_HZ  (configCPU_CLOCK_HZ)  //定义systick的时钟频率 默认与系统时钟相同。\n#define configTICK_RATE_HZ\t\t\t( ( TickType_t ) 1000 )\n#define configMAX_PRIORITIES\t\t( 32 )  //可使用最大优先级\n#define configMINIMAL_STACK_SIZE\t( ( unsigned short ) 128 )\n\n#define configMAX_TASK_NAME_LEN\t\t( 16 )\n\n#define configUSE_16_BIT_TICKS\t\t0   //设置系统节拍计数器的数据类型 0为32位\n#define configIDLE_SHOULD_YIELD\t\t1   //1同优先级的任务可以抢占空闲任务\n#define configUSE_TASK_NOTIFCATIONS 1 //1 使能任务间的消息传递\n#define configENABLE_BACKWARD_COMPATIBILITY 0 //1 兼容老版本API函数\n\n/*Memory Allocation*/\n#define configTOTAL_HEAP_SIZE\t\t( ( size_t ) ( 17 * 1024 ) )  //17k总堆栈\n#define configSUPPORT_STATIC_ALLOCATION   0   //1 支持静态申请分配内存，默认0\n#define configSUPPORT_DYNAMIC_ALLOCATION  1   //1 支持动态申请分配内存，默认1\n\n/*Debug*/\n#define configUSE_TRACE_FACILITY\t1   //使能可视化追踪调试\n#define configUSE_STATS_FORMATTING_FUNCTION 1\n\n/*Software Timer*/\n#define configUSE_TIMERS  1 //1 使能软件定时器\n#define configTIMER_TASK_PRIORITY (configMAX_PRIORITIES - 1)\n#define configTIMER_QUEUE_LENGTH  5\n#define configTIMER_TASK_STACK_DEPTH  (configMINIMAL_STACK_SIZE * 2)\n\n\n/* Set the following definitions to 1 to include the API function, or zero\nto exclude the API function. */\n\n#define INCLUDE_vTaskPrioritySet\t\t    1   //设置任务优先级 \n#define INCLUDE_uxTaskPriorityGet\t\t    1   //获取任务优先级\n#define INCLUDE_vTaskDelete\t\t\t\t      1   //删除任务\n#define INCLUDE_vTaskCleanUpResources\t  1   //\n#define INCLUDE_vTaskSuspend\t\t\t      1   //挂起任务\n#define INCLUDE_xResumeFromISR          1   //恢复在中断中挂起的任务\n#define INCLUDE_vTaskDelayUntil\t\t\t    1   //任务绝对延时\n#define INCLUDE_vTaskDelay\t\t\t\t      1   //任务延时\n#define INCLUDE_xTaskGetSchedulerState  1   //\n#define INCLUDE_xTaskGetCurrentTaskHandle 1 //\n//#define INCLUDE_xTimerPendFunctionCall  1   //\n#define INCLUDE_eTaskGetState           1   //\n\n/* This is the raw value as per the Cortex-M3 NVIC.  Values can be 255\n(lowest) to 0 (1?) (highest). */\n#define configKERNEL_INTERRUPT_PRIORITY \t\t255\n/* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!!\nSee http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. */\n#define configMAX_SYSCALL_INTERRUPT_PRIORITY \t191 /* equivalent to 0xb0, or priority 11. */\n\n/*FreeRTOS interrupt relative define*/\n#define xPortPendSVHandler    PendSV_Handler\n#define vPortSVCHandler       SVC_Handler\n\n/* This is the value being used as per the ST library which permits 16\npriority values, 0 to 15.  This must correspond to the\nconfigKERNEL_INTERRUPT_PRIORITY setting.  Here 15 corresponds to the lowest\nNVIC value of 255. */\n#define configLIBRARY_KERNEL_INTERRUPT_PRIORITY\t15\n\n/*Assert*/\n//#define vAssertCalled(char, int) printf(&quot;Error: %s, %d\\r\\n&quot;, char, int)\n//#define configASSERT(x) if((x) == 0) vAssertCalled(__FILE__,__LINE__)\n\n\n#endif /* FREERTOS_CONFIG_H */\n3．修改系统相关配置Systick 系统滴答时钟需要与FreeRTOSConfig.h里的configTICK_RATE_HZ对应滴答时钟中断需要加上任务切换\n4．修改中断相关配置Systick中断（自己配置）、SVC中断、PendSV中断（这俩在freeRTOS中有定义）因而在stm32f1xx_it.c中需要将相关中断定义注释掉\n一般要在SysTick_Handler中写\nbashvoid SysTick_Handler(void)&#123;\n  if(xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)&#123;//任务切换相关\n    xPortSysTickHandler(); //SVC和PendSV中断入口\n  &#125;\n&#125;没有注释编译就会出现这种情况\nbash\n.\\Objects\\Project.axf: Error: L6200E: Symbol SVC_Handler multiply defined (by port.o and stm32f10x_it.o).\n.\\Objects\\Project.axf: Error: L6200E: Symbol PendSV_Handler multiply defined (by port.o and stm32f10x_it.o).5．添加应用程序因人而异啦~\n源码参考基于STM32F103C8T6的FreeRTOS移植与简单配置（没有测试程序捏~~）https://github.com/Yesord/FreeROTS_STM32F103C8T6\nFreeRTOS移植可能出现的问题1.在学习FreeRTOS移植后，编译出现bash…\\OBJ\\LED.axf: Error: L6218E: Undefined symbol xTaskGetSchedulerState (referred from delay.o).出现这个错误的原因是xTaskGetSchedulerState的值没有改，需要在FreeRTOS.h中将其宏定义的值改为1即可。也可以去FreeRTOSConfig.h中把INCLUDE_xTaskGetScheduler 赋1\n后记配图还待更新，小编比较懒，不定时更新 ^.^\n","slug":"FreeRTOS的移植","date":"2023-10-17T09:33:25.000Z","categories_index":"Embedded","tags_index":"RTOS,STM32","author_index":"PIKO"},{"id":"5fb0b2232f7b008486299018a9a2ee11","title":"markdown-example","content":"@TOC\n欢迎使用Markdown编辑器你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n新的改变我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：\n\n全新的界面设计 ，将会带来全新的写作体验；\n在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示；\n增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；\n全新的 KaTeX数学公式 语法；\n增加了支持甘特图的mermaid语法^1 功能；\n增加了 多屏幕编辑 Markdown文章功能；\n增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间；\n增加了 检查列表 功能。\n\n功能快捷键撤销：Ctrl/Command + Z重做：Ctrl/Command + Y加粗：Ctrl/Command + B斜体：Ctrl/Command + I标题：Ctrl/Command + Shift + H无序列表：Ctrl/Command + Shift + U有序列表：Ctrl/Command + Shift + O检查列表：Ctrl/Command + Shift + C插入代码：Ctrl/Command + Shift + K插入链接：Ctrl/Command + Shift + L插入图片：Ctrl/Command + Shift + G查找：Ctrl/Command + F替换：Ctrl/Command + G\n合理的创建标题，有助于目录的生成直接输入1次#，并按下space后，将生成1级标题。输入2次#，并按下space后，将生成2级标题。以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。\n如何改变文本的样式强调文本 强调文本\n加粗文本 加粗文本\n&#x3D;&#x3D;标记文本&#x3D;&#x3D;\n删除文本\n\n\n\n\n\n\n\n\n\n引用文本\nH2O is是液体。\n2^10^ 运算结果是 1024.\n插入链接与图片链接: link.\n图片: \n带尺寸的图片: ![Alt](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw &#x3D;30x30)\n居中的图片: \n居中并且带尺寸的图片: ![Alt](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw#pic_center &#x3D;30x30)\n当然，我们为了让用户更加便捷，我们增加了图片拖拽功能。\n如何插入一段漂亮的代码片去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 代码片.\n​javascript // An highlighted block var foo = &#39;bar&#39;; ​\n生成一个适合你的列表\n项目\n项目\n项目\n\n\n\n\n\n\n项目1\n项目2\n项目3\n\n\n 计划任务\n 完成任务\n\n创建一个表格一个简单的表格是这么创建的：\n\n\n\n项目\nValue\n\n\n\n电脑\n$1600\n\n\n手机\n$12\n\n\n导管\n$1\n\n\n设定内容居中、居左、居右使用:---------:居中使用:----------居左使用----------:居右\n\n\n\n第一列\n第二列\n第三列\n\n\n\n第一列文本居中\n第二列文本居右\n第三列文本居左\n\n\nSmartyPantsSmartyPants将ASCII标点字符转换为“智能”印刷标点HTML实体。例如：\n\n\n\nTYPE\nASCII\nHTML\n\n\n\nSingle backticks\n&#39;Isn&#39;t this fun?&#39;\n‘Isn’t this fun?’\n\n\nQuotes\n&quot;Isn&#39;t this fun?&quot;\n“Isn’t this fun?”\n\n\nDashes\n-- is en-dash, --- is em-dash\n– is en-dash, — is em-dash\n\n\n创建一个自定义列表MarkdownText-to-HTML conversion toolAuthors:  JohnLuke如何创建一个注脚一个具有注脚的文本。^2\n注释也是必不可少的Markdown将文本转换为 HTML。\n*[HTML]:   超文本标记语言\nKaTeX数学公式您可以使用渲染LaTeX数学表达式 KaTeX:\nGamma公式展示 $\\Gamma(n) &#x3D; (n-1)!\\quad\\foralln\\in\\mathbb N$ 是通过欧拉积分\n$$\\Gamma(z) &#x3D; \\int_0^\\infty t^{z-1}e^{-t}dt,.$$\n\n\n\n\n\n\n\n\n\n你可以找到更多关于的信息 LaTeX 数学表达式here.\n新的甘特图功能，丰富你的文章​mermaid gantt         dateFormat  YYYY-MM-DD         title Adding GANTT diagram functionality to mermaid         section 现有任务         已完成               :done,    des1, 2014-01-06,2014-01-08         进行中               :active,  des2, 2014-01-09, 3d         计划一               :         des3, after des2, 5d         计划二               :         des4, after des3, 5d ​\n\n关于 甘特图 语法，参考 这儿,\n\nUML 图表可以使用UML图表进行渲染。 Mermaid. 例如下面产生的一个序列图：\n​&#96;&#96;&#96;mermaidsequenceDiagram张三 -&gt;&gt; 李四: 你好！李四, 最近怎么样?李四–&gt;&gt;王五: 你最近怎么样，王五？李四–x 张三: 我很好，谢谢!李四-x 王五: 我很好，谢谢!Note right of 王五: 李四想了很长时间, 文字太长了不适合放在一行.\n李四–&gt;&gt;张三: 打量着王五…张三-&gt;&gt;王五: 很好… 王五, 你怎么样?​&#96;&#96;&#96;\n这将产生一个流程图。:\n​mermaid graph LR A[长方形] -- 链接 --&gt; B((圆)) A --&gt; C(圆角长方形) B --&gt; D&#123;菱形&#125; C --&gt; D ​\n\n关于 Mermaid 语法，参考 这儿,\n\nFLowchart流程图我们依旧会支持flowchart的流程图：\n​&#96;&#96;&#96;mermaidflowchatst&#x3D;&gt;start: 开始e&#x3D;&gt;end: 结束op&#x3D;&gt;operation: 我的操作cond&#x3D;&gt;condition: 确认？\nst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op​&#96;&#96;&#96;\n\n关于 Flowchart流程图 语法，参考 这儿.\n\n导出与导入导出如果你想尝试使用此编辑器, 你可以在此篇文章任意编辑。当你完成了一篇文章的写作, 在上方工具栏找到 文章导出 ，生成一个.md文件或者.html文件进行本地保存。\n导入如果你想加载一篇你写过的.md文件，在上方工具栏可以选择导入功能进行对应扩展名的文件导入，继续你的创作。\n","slug":"markdown-example","date":"2023-10-17T09:01:15.000Z","categories_index":"","tags_index":"blog","author_index":"PIKO"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new postbash$ hexo new &quot;My New Post&quot;More info: Writing\nRun serverbash$ hexo serverMore info: Server\nGenerate static filesbash$ hexo generateMore info: Generating\nDeploy to remote sitesbash$ hexo deployBy the Wayactually you can combine Generate with Deploy\nbash$ hexo g &amp;&amp; hexo dthe new markdown file will be restored in yourblog&#x2F;source&#x2F;_post&#x2F;\nOf course SSH deployment is much slower than the local deployment, you can use the command as follow to deploy in local so that you can check your new blog quickly.\nbash$ hexo sMore info: Deployment\n","slug":"hello-world","date":"2023-10-17T00:52:26.197Z","categories_index":"","tags_index":"blog","author_index":"PIKO"}]